###############################################################################
# This file is part of "Object Teams Development Tooling"-Software
#
# Copyright 2004, 2010 Fraunhofer Gesellschaft, Munich, Germany,
# for its Fraunhofer Institute for Computer Architecture and Software
# Technology (FIRST), Berlin, Germany and Technical University Berlin,
# Germany.
#
# This program and the accompanying materials
# are made available under the terms of the Eclipse Public License 2.0
# which accompanies this distribution, and is available at
# https://www.eclipse.org/legal/epl-2.0/
#
# SPDX-License-Identifier: EPL-2.0
#
# Please visit http://www.eclipse.org/objectteams for updates and contact.
#
# Contributors:
# Fraunhofer FIRST - Initial API and implementation
# Technical University Berlin - Initial API and implementation
###############################################################################

# OT refactor menu
OTRefactorMenu.label = Refac&tor (OT/J)

# OT refactorings
# ExtractMethodRefactoring
OTExtractMethodRefactoring.name = Extract Method {0} in {1}
OTExtractMethodRefactoring.not_a_base_class = Refactoring cannot be performed! Selected statements are not part of a regular OO-class!
OTExtractMethodRefactoring.checking_overloading = Checking overloading
OTExtractMethodRefactoring.overloading = Extracted method will be overloaded after refactoring!
OTExtractMethodRefactoring.ambiguous_method_specifier = Refactoring cannot be performed! There would be an ambiguous method specifier in a method binding after extracting!

# RenameTypeRefactoring
OTRenameTypeRefactoring.role_type = Role type declared inside ''{0}'' is named {1}!
OTRenameTypeRefactoring.nested_team_type = Nested team type declared inside ''{0}'' is named {1}!

# RenameMethodRefactoring
OTRenameVirtualMethodProcessor.not_a_base_class = Refactoring cannot be performed! Selected method is not a member of a regular OO-class!
OTRenameNonVirtualMethodProcessor.not_a_base_class = Refactoring cannot be performed! Selected method is not a member of a regular OO-class!
OTRenameVirtualMethodProcessor.update_base_call_occurrence = Update base call occurrence
RenameAdaptor.error_check_overload_ambiguity=Error while checking overloading and ambiguity
RenameVirtualMethodRefactoring.special_team_method=A Team implements this interface. You cannot use a special team method name

# Rename Package
RenameAdaptor.error_binary_class_potential_team_package=Found binary class in potential team package, can't rename.
RenameAdaptor.error_cannot_rename_team_package=Cannot rename a team package, please select the corresponding team class instead.
RenameAdaptor.error_parent_package_not_exist=Parent package does not exist, check for team package failed.

# RenameFieldRefactoring
OTRenameFieldProcessor.not_a_base_class = Refactoring cannot be performed! Selected field is not a member of a regular OO-class!

# MoveStaticMembersRefactoring
OTMoveStaticMembersProcessor.not_a_base_class = Refactoring cannot be performed! Selected method is not a member of a regular OO-class!

# MoveInstanceMethodRefactoring
OTMoveInstanceMethodRefactoring.not_a_base_class = Refactoring cannot be performed! Selected method is not a member of a regular OO-class!

# visibility checks
OTInstanceMethodMover.no_private_methods = Refactoring cannot be performed! Selected method is declared private!
# field access/assignment checks
OTInstanceMethodMover.method_accesses_private_field = Target method accesses a private field of the enclosing type and shall be moved to outside of this enclosing type (the new receiver is not the type of the field)!
OTInstanceMethodMover.method_accesses_protected_field = Target method accesses a protected field of the enclosing type and shall be moved to a class in a different package (the new receiver is not the type of the field)!
OTInstanceMethodMover.method_accesses_package_visible_field = Target method accesses a package-visible field of the enclosing type and shall be moved to a class in a different package (the new receiver is not the type of the field)!
# overriding checks
OTInstanceMethodMover.role_method_overrides_moved_method = Moved method would be overridden by a role method after moving!
OTInstanceMethodMover.base_method_overrides_moved_method = Moved method would be overridden by a base method after moving!
OTInstanceMethodMover.moved_method_is_overridden_in_regular_subclass = Moved method would be overridden in a regular subclass of the new receiver after moving!
# ambiguity checks
OTInstanceMethodMover.ambiguous_role_method_specifier_in_callin = There would be an ambiguous role method specifier in a callin method binding after moving!
OTInstanceMethodMover.ambiguous_base_method_specifier_in_callin = There would be an ambiguous base method specifier in a callin method binding after moving!
OTInstanceMethodMover.ambiguous_role_method_specifier_in_callout = There would be an ambiguous role method specifier in a callout method binding after moving!
OTInstanceMethodMover.ambiguous_base_method_specifier_in_callout = There would be an ambiguous base method specifier in a callout method binding after moving!
# duplicate checks
OTInstanceMethodMover.duplicate_method_in_new_receiver = There already exists a method with the same name and the same parameters in the new receiver!

# Reorg (cut, copy&paste, delete)
ReorgUtils.21 = team ''{0}''
ReorgUtils.22 = nested team ''{0}''
ReorgUtils.23 = role ''{0}''
ReorgUtils.24 = callout binding ''{0}''
ReorgUtils.25 = callout to field binding ''{0}''
ReorgUtils.26 = callin binding ''{0}''

#Organize imports
OrganizeImportsAction.label = Or&ganize Imports (OT/J)
